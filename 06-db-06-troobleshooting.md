# Домашнее задание к занятию 6. «Troubleshooting»

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести эту операцию:

- напишите список операций, которые вы будете производить для остановки запроса пользователя;
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.

---
### Ответ
* ```CRUD operations``` - create, read, update, and delete 
* ```Метод db.currentOp()``` - сообщает о текущих операциях, выполняемых в экземпляре mongod.
* ```Метод db.killOp()``` - прерывает операцию.
* Что-бы оптимизировать выполниение, надо для начала построить план выполонения запроса (используя Методы cursor.explain() и db.collection.explain() возвращают информацию о выполнении запроса,), и на оновании этого запроса найти операции на которые СУБД затрачивает больше всего времени, при необходимости построить индексы.

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:

- сначала происходит рост отношения записанных значений к истекшим,
- Redis блокирует операции записи.

Как вы думаете, в чём может быть проблема?
---
### Ответ
* **Если исходить из информации в документации** ```В основном это означает, что если в базе данных есть много-много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия, Redis может заблокировать, чтобы получить процент ключей, срок действия которых уже истек. ниже 25%. Многие ключи, срок действия которых истекает в один и тот же момент, могут быть источником задержки.```
 
## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения этой проблемы вы можете предложить?
___
### Ответ
* По опыту использования MS SQL Server, ошибки подобного рода возникают, когда запрос выполняется дольше выделенного времени. Иногда форма "во время запроса" возникает, когда миллионы строк отправляются как часть одного или нескольких запросов. Если вы знаете, что это происходит, вы должны попытаться увеличить значение net_read_timeout со своего значения по умолчанию от 30 секунд до 60 секунд или дольше, достаточного для завершения передачи данных.
* **Решением проблемы** может быть оптимизация запроса или увеличением времи ожидания подключения ```connect_timeout```. Другая возможность — это большой запрос. Я полагаю, они имеют в виду: большой результат запроса. Итак, говорят, что вам нужно увеличить ```max_allowed_packet``` на сервере.

## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объёмом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили эту проблему?

---
### Ответ
* Когда у сервера или процесса заканчивается память, Linux предлагает 2 пути решения: обрушить всю систему или завершить процесс (приложение), который съедает память. Лучше, конечно, завершить процесс и спасти ОС от аварийного завершения. В двух словах, Out-Of-Memory Killer — это процесс, который завершает приложение, чтобы спасти ядро от сбоя. Он жертвует приложением, чтобы сохранить работу ОС. Одна из главных задач Linux — выделять память процессам, когда они ее просят. Обычно процесс или приложение запрашивают у ОС память, а сами используют ее не полностью. Если ОС будет выдавать память всем, кто ее просит, но не планирует использовать, очень скоро память закончится, и система откажет. Чтобы этого избежать, ОС резервирует память за процессом, но фактически не выдает ее. Память выделяется, только когда процесс действительно собирается ее использовать. Случается, что у ОС нет свободной памяти, но она закрепляет память за процессом, и когда процессу она нужна, ОС выделяет ее, если может. Минус в том, что иногда ОС резервирует память, но в нужный момент свободной памяти нет, и происходит сбой системы. OOM играет важную роль в этом сценарии и завершает процессы, чтобы уберечь ядро от паники
* Как решением это проблемы может быть также оптимизация долговыполняющися запросов и индексация таблиц.  Как вариант это увеличить ОЗУ сервера, чтобы не было нехватки памяти. Так же возможно создать кластер серверов. Один мощный другой послабее и балансировать нагрузку между ними.
