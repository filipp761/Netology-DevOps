# Домашнее задание к занятию "6.1. Типы и структура СУБД"

## Введение

Перед выполнением задания вы можете ознакомиться с 
[дополнительными материалами](https://github.com/netology-code/virt-homeworks/tree/master/additional/README.md).

## Задача 1

Архитектор ПО решил проконсультироваться у вас, какой тип БД 
лучше выбрать для хранения определенных данных.

Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД:

- Электронные чеки в json виде
- Склады и автомобильные дороги для логистической компании
- Генеалогические деревья
- Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации
- Отношения клиент-покупка для интернет-магазина

Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.
____
### Ответ:

1) Для электронных чеков в json лучше всего подойдет такой тип СУБД как NoSQL. Так как электронные чеки не имеют четков структруры данных и связи между информацией. Могут иметь различное количество и набор данных. Подойдет тип NoSQL СУБД - **"Ключ - значение"** (Redis, Memcached) или **документоориентированные** (MongoDB).

2) Для хранения типа сущностей "Склады и автомобильные дороги для логистической компании" подойдет тип СУБД - **графовые**, для удобства составления наиболее подходящих маршрутов, в зависимости от веса операции.
 
3) Для генеалогического дерева, на мой взгляд, лучше всего подойдет **графовая или иерархическая** база данных, так как в данном случаи нужны связи родитель - потомок. (Neo4j, Amazon Neptune, InfiniteGraph, InfoGrid) или (Caché)

4) Для хранения кеша идентификаторов клиентов с ограниченным временем жизни для движка аутентификации, тоже лучше всего подойдет тип СУБД, такой как **ключ - значение**Данные которой хранятся в оперативной памяти (Redis)
 
5) Для типа сущности клиент-покупка для интернет магазина, тут на мой взгляд можно объеденить два разным типа СУБД, **ключ-значение** - для сохранения данных о покупках и часть данных переносить в графовую, чтобы проводить анализ и выдавать рекомендации.

## Задача 2

Вы создали распределенное высоконагруженное приложение и хотите классифицировать его согласно 
CAP-теореме. Какой классификации по CAP-теореме соответствует ваша система, если 
(каждый пункт - это отдельная реализация вашей системы и для каждого пункта надо привести классификацию):

- Данные записываются на все узлы с задержкой до часа (асинхронная запись) 
- При сетевых сбоях, система может разделиться на 2 раздельных кластера 
- Система может не прислать корректный ответ или сбросить соединение

А согласно PACELC-теореме, как бы вы классифицировали данные реализации?
____
### Ответ:

* **CAP**
  * Данные записываются на все узлы с задержкой до часа (асинхронная запись) **СА** (**Согласованность (Consistency)**)
  * При сетевых сбоях, система может разделиться на 2 раздельных кластера **CP** (**Доступность (Availability)**)
  * Система может не прислать корректный ответ или сбросить соединение **AP** (**Терпимость к разделению сети. (Partition Tolerance)**)

**Согласованность (C)**: все узлы одновременно видят одни и те же данные. Это означает, что пользователи могут читать или писать с любого узла в системе и получать одни и те же данные. Это эквивалентно наличию одной актуальной копии данных.

**Доступность (A)**: Доступность означает, что каждый запрос, полученный исправным узлом в системе, должен приводить к ответу. Даже при серьезных сбоях сети все запросы должны завершаться. Проще говоря, доступность означает способность системы оставаться доступной, даже если один или несколько узлов в системе выходят из строя.

**Допуск на разделение (P)**: раздел - это разрыв связи (или сетевой сбой) между любыми двумя узлами в системе, т. е. оба узла работают, но не могут связываться друг с другом. Система, терпимая к разделам, продолжает работать, даже если в системе есть разделы. Такая система может выдержать любой сетевой сбой, который не приведет к отказу всей сети. Данные достаточно реплицируются между комбинациями узлов и сетей, чтобы поддерживать систему в рабочем состоянии при периодических отключениях.

* **PACELC**
  * Данные записываются на все узлы с задержкой до часа (асинхронная запись) (**PC / EC: они всегда выбирают согласованность, отказываясь от доступности и меньшей задержки.**)
  * При сетевых сбоях, система может разделиться на 2 раздельных кластера (**PC / EC: они всегда выбирают согласованность, отказываясь от доступности и меньшей задержки.**)
  * Система может не прислать корректный ответ или сбросить соединение (**PA / EC**)

## Задача 3

Могут ли в одной системе сочетаться принципы BASE и ACID? Почему?
____
### Ответ:

**ACID** — требования к СУБД, обеспечивающие надёжность и предсказуемость её работы.
* A — atomicity (атомарность) — никакая транзакция не будет зафиксирована в БД частично
* C — consistency (согласованность) — каждая успешная транзакция фиксирует только допустимые результаты
* I — isolation (изоляция) — параллельные транзакции не искажают результат друг друга
* D — durability (стойкость) — гарантия применения успешных транзакций независимо от низкоуровневых проблем

**BASE** — принцип, противопоставляющий себя ACID.

* BA — basically availability (базовая доступность) — деградация части узлов ведёт к деградации части сессий, исключая полную деградацию системы
* S — soft state (неустойчивое состояние) — уменьшение времени хранения сессий и фиксация обновлений только критичных операций
* E — eventually consistent (конечная согласованность) — изменение состояния в конечном итоге применится на все системы

В одной система принципы BASE и ACID сочетаться НЕ могут, так как это два противоположны по принципу друг другу.

Принцип ACID позволяет создавать высоконадежные системы (не позволит сохранить транзакцию частично), при получении уведомления об успешном выполнении транзакции, можно быть уверенным, что операция выполнилась. 

А принцип BASE позволяет создавать высонагруженные системы, под базовой доступностью подразумевается такой подход к проектированию приложения, чтобы сбой в некоторых узлах приводил к отказу в обслуживании только для незначительной части сессий при сохранении доступности в большинстве случаев. Неустойчивое состояние подразумевает возможность жертвовать долговременным хранением состояния сессий (таких как промежуточные результаты выборок, информация о навигации, контексте), при этом концентрируясь на фиксации обновлений только критичных операций.

Источник: https://intellect.icu/teorema-cap-base-arkhitektura-8786

## Задача 4

Вам дали задачу написать системное решение, основой которого бы послужили:

- фиксация некоторых значений с временем жизни
- реакция на истечение таймаута

Вы слышали о key-value хранилище, которое имеет механизм [Pub/Sub](https://habr.com/ru/post/278237/). 
Что это за система? Какие минусы выбора данной системы?

____
### Ответ:

Здесь, скорее всего, речь идет о **Redis.**

**Минусы данной системы**

* Если издатель по каким-либо причинам выходит из строя, то он теряет всех своих подписчиков
* Издателю необходимо знать точный адрес всех его подписчиков
* Издатель может перегрузить работой своих подписчиков, если данные публикуются быстрее, чем обрабатываются
* Сообщение удаляется из буфера издателя сразу после публикации, не зависимо от того, какому числу подписчиков оно доставлено и как быстро те сумели обработать это сообщение.
* Все подписчики получат сообщение одновременно. Подписчики сами должны как-то между собой согласовывать порядок обработки одного и того же сообщения.
* Нет встроенного механизма подтверждения успешной обработки сообщения подписчиком. Если подписчик получил сообщение и свалился во время обработки, то издатель об этом не узнает.


Источник: https://habr.com/ru/articles/456270/

---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
