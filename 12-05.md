# Домашнее задание к занятию 12.5. «Индексы»
Решение нужно прислать одним SQL файлом, содержащим запросы по всем заданиям.

Любые вопросы по решению задач задавайте в чате учебной группы.

Задание можно выполнить как в любом IDE, так и в командной строке.

## Задание 1

Напишите запрос к учебной базе данных, который вернёт процентное отношение общего размера всех индексов к общему размеру всех таблиц.

____

Ответ:
```SQL
SELECT SUM(DATA_LENGTH) as 'Размер таблиц',
SUM (INDEX_LENGTH) as 'Размер индексов',
SUM (INDEX_LENGTH)/SUM(DATA_LENGTH)*100 as '%, отношене таблицы/индексы'
FROM INFORMATION_SCHEMA.TABLES
```
![alt text](https://github.com/filipp761/12.4/blob/main/img/12_5_1.png)

## Задание 2

Напишите запрос к учебной базе данных, который вернёт процентное отношение общего размера всех индексов к общему размеру всех таблиц.
Выполните explain analyze следующего запроса:
```SQL
select distinct concat(c.last_name, ' ', c.first_name), sum(p.amount) over (partition by c.customer_id, f.title)
from payment p, rental r, customer c, inventory i, film f
where date(p.payment_date) = '2005-07-30' and p.payment_date = r.rental_date and r.customer_id = c.customer_id and i.inventory_id = r.inventory_id
```
Gеречислите узкие места;
Оптимизируйте запрос: внесите корректировки по использованию операторов, при необходимости добавьте индексы.
____

Ответ:

Нет необходимоси вывода таблицы film и его столбца film.title
Перенес условия объединения таблиц из WHERE в JOIN

![alt text](https://github.com/filipp761/12.4/blob/main/img/12_5_2.png)

## Задание 3*
Самостоятельно изучите, какие типы индексов используются в PostgreSQL. 

Перечислите те индексы, которые используются в PostgreSQL, а в MySQL — нет.

Приведите ответ в свободной форме.
____
Ответ:

**Типы индексов  PostgreSQL**

* 11.2.1. B-дерево
* 11.2.2. Хеш
* 11.2.3. GiST
* 11.2.4. SP-GiST
* 11.2.5. GIN
* 11.2.6. BRIN

**PostgreSQL** поддерживает несколько типов индексов: B-дерево, хеш, GiST, SP-GiST, GIN, BRIN и расширение bloom. Для разных типов индексов применяются разные алгоритмы, ориентированные на определённые типы запросов. По умолчанию команда CREATE INDEX создаёт индексы-B-деревья, эффективные в большинстве случаев. Выбрать другой тип можно, написав название типа индекса после ключевого слова USING. Например, создать хеш-индекс можно так:
CREATE INDEX имя ON таблица USING HASH (столбец);

**11.2.1. B-дерево**

B-деревья могут работать в условиях на равенство и в проверках диапазонов с данными, которые можно отсортировать в некотором порядке. Точнее, планировщик запросов PostgreSQL может задействовать индекс-B-дерево, когда индексируемый столбец участвует в сравнении с одним из следующих операторов:

<   <=   =   >=   >

При обработке конструкций, представимых как сочетание этих операторов, например BETWEEN и IN, так же может выполняться поиск по индексу-B-дереву. Кроме того, такие индексы могут использоваться и в условиях IS NULL и IS NOT NULL по индексированным столбцам.
Также оптимизатор может использовать эти индексы в запросах с операторами сравнения по шаблону LIKE и ~, если этот шаблон определяется константой, и он привязан к началу строки — например, col LIKE 'foo%' или col ~ '^foo', но не col LIKE '%bar'. Но если ваша база данных использует не локаль C, для поддержки индексирования запросов с шаблонами вам потребуется создать индекс со специальным классом операторов. Индексы-B-деревья можно использовать и для ILIKE и ~*, но только если шаблон начинается не с алфавитных символов, то есть символов, не подверженных преобразованию регистра.
B-деревья могут также применяться для получения данных, отсортированных по порядку. Это не всегда быстрее простого сканирования и сортировки, но иногда бывает полезно.

**11.2.2. Хеш**

Хеш-индексы хранят 32-битный хеш-код, полученный из значения индексированного столбца, поэтому хеш-индексы работают только с простыми условиями равенства. Планировщик запросов может применить хеш-индекс, только если индексируемый столбец участвует в сравнении с оператором =. Создать такой индекс можно следующей командой:
CREATE INDEX имя ON таблица USING HASH (столбец);

**11.2.3. GiST**

GiST-индексы представляют собой не просто разновидность индексов, а инфраструктуру, позволяющую реализовать много разных стратегий индексирования. Как следствие, GiST-индексы могут применяться с разными операторами, в зависимости от стратегии индексирования (класса операторов). Например, стандартный дистрибутив PostgreSQL включает классы операторов GiST для нескольких двумерных типов геометрических данных, что позволяет применять индексы в запросах с операторами:

<<   &<   &>   >>   <<|   &<|   |&>   |>>   @>   <@   ~=   &&

GiST-индексы также могут оптимизировать поиск «ближайшего соседа», например такой:
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
который возвращает десять расположений, ближайших к заданной точке. Возможность такого применения индекса опять же зависит от класса используемого оператора. 

**11.2.4. SP-GiST**

Индексы SP-GiST, как и GiST, предоставляют инфраструктуру, поддерживающую различные типы поиска. SP-GiST позволяет организовывать на диске самые разные несбалансированные структуры данных, такие как деревья квадрантов, k-мерные и префиксные деревья. Например, стандартный дистрибутив PostgreSQL включает классы операторов SP-GiST для точек в двумерном пространстве, что позволяет применять индексы в запросах с операторами:

<<   >>   ~=   <@   <<|   |>>

Индексы SP-GiST, как и GiST, поддерживают поиск ближайших соседей. 

**11.2.5. GIN**

GIN-индексы представляют собой «инвертированные индексы», в которых могут содержаться значения с несколькими ключами, например массивы. Инвертированный индекс содержит отдельный элемент для значения каждого компонента, и может эффективно работать в запросах, проверяющих присутствие определённых значений компонентов.
Подобно GiST и SP-GiST, индексы GIN могут поддерживать различные определённые пользователем стратегии и в зависимости от них могут применяться с разными операторами. Например, стандартный дистрибутив PostgreSQL включает класс операторов GIN для массивов, что позволяет применять индексы в запросах с операторами:

<@   @>   =   &&

**11.2.6. BRIN**

BRIN-индексы (сокращение от Block Range INdexes, Индексы зон блоков) хранят обобщённые сведения о значениях, находящихся в физически последовательно расположенных
блоках таблицы. Поэтому такие индексы наиболее эффективны для столбцов, значения в которых хорошо коррелируют с физическим порядком столбцов таблицы. Подобно GiST,
SP-GiST и GIN, индексы BRIN могут поддерживать определённые пользователем стратегии и в зависимости от них применяться с разными операторами. Для типов данных, 
имеющих линейный порядок сортировки, записям в индексе соответствуют минимальные и максимальные значения данных в столбце для каждой зоны блоков. Это позволяет поддерживать запросы со следующими операторами:

<   <=   =   >=   >

![alt text](https://github.com/filipp761/12.4/blob/main/img/12_5_3.png)
